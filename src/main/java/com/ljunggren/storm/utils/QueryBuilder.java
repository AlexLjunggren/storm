package com.ljunggren.storm.utils;

import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

import org.apache.commons.lang3.StringUtils;

import com.ljunggren.storm.Paging;
import com.ljunggren.storm.annotation.entity.ColumnProperty;
import com.ljunggren.storm.annotation.entity.Id;
import com.ljunggren.storm.annotation.entity.Table;

public class QueryBuilder {
    
    private Object object;
    private List<Field> fields;
    private Field idField;
    
    public static final String PAGING = "%s offset %d rows fetch next %d rows only";
    public static final String INSERT = "insert into %s (%s) values (%s)";
    public static final String UPDATE = "update %s set %s where %s = ?";
    public static final String DELETE = "delete from %s where %s = ?";
    
    public QueryBuilder() {}
    
    public QueryBuilder(Object object) {
        this.object = object;
        this.fields = ReflectionUtils.getObjectFields(object.getClass());
        this.idField = AnnotationUtils.findFieldByAnnotation(Id.class, fields);
    }
    
    public String buildPagingSQL(String sql, Paging paging) {
        int page = paging.getPage() - 1;
        int rows = paging.getRows();
        int offset = page * rows;
        return String.format(PAGING, sql, offset, rows);
    }
    
    public Object[] getPagingArgs(Object[] args) {
        return Arrays.stream(args).filter(arg -> arg.getClass() != Paging.class).toArray();
    }

    public String buildInsertSQL() {
        String table = getTableName(object.getClass());
        List<String> columns = getColumnNames(fields);
        List<String> questionMarks = generateQuestionMarks(columns);
        return String.format(INSERT, table, StringUtils.join(columns, ", "), StringUtils.join(questionMarks, ", "));
    }
    
    public Object[] getInsertArgs() {
        List<Object> arguments = fields.stream()
                .filter(field -> !AnnotationUtils.isAutoGeneratedId(field))
                .filter(field -> !AnnotationUtils.isTransient(field))
                .filter(field -> !field.isSynthetic())
                .filter(field -> ReflectionUtils.isPrimitive(field.getType()) || ReflectionUtils.isString(field.getType()))
                .map(ExceptionUtils.rethrowFunction(field -> ReflectionUtils.getFieldValue(field, object)))
                .collect(Collectors.toList());
        return arguments.toArray();
    }
    
    public String buildUpdateSQL() {
        String table = getTableName(object.getClass());
        List<String> columns = getColumnNames(fields).stream()
                .map(column -> column + " = ?").collect(Collectors.toList());
        String idName = idField.getName();
        return String.format(UPDATE, table, StringUtils.join(columns, ", "), idName);
    }
    
    public Object[] getUpdateArgs() throws IllegalAccessException {
        List<Object> arguments = fields.stream()
                .filter(field -> field != idField)
                .filter(field -> !AnnotationUtils.isTransient(field))
                .filter(field -> !field.isSynthetic())
                .filter(field -> ReflectionUtils.isPrimitive(field.getType()) || ReflectionUtils.isString(field.getType()))
                .map(ExceptionUtils.rethrowFunction(field -> ReflectionUtils.getFieldValue(field, object)))
                .collect(Collectors.toList());
        arguments.add(ReflectionUtils.getFieldValue(idField, object));
        return arguments.toArray();
    }
    
    public String buildDeleteSQL() {
        String table = getTableName(object.getClass());
        String idName = idField.getName();
        return String.format(DELETE, table, idName);
    }
    
    public Object[] getDeleteArgs() throws IllegalAccessException {
        return new Object[] {ReflectionUtils.getFieldValue(idField, object)};
    }
    
    private String getTableName(Class<?> clazz) {
        Table table = AnnotationUtils.getAnnotationFromClass(Table.class, clazz);
        return table == null ? null : table.name();
    }
    
    private List<String> getColumnNames(List<Field> fields) {
        return fields.stream()
                .filter(field -> !AnnotationUtils.isAutoGeneratedId(field))
                .filter(field -> !AnnotationUtils.isTransient(field))
                .filter(field -> !field.isSynthetic())
                .filter(field -> ReflectionUtils.isPrimitive(field.getType()) || ReflectionUtils.isString(field.getType()))
                .map(field -> {
                    Annotation columnProperty = AnnotationUtils.getAnnotationFromField(ColumnProperty.class, field);
                    if (columnProperty != null) {
                        return ((ColumnProperty) columnProperty).name();
                    }
                    return field.getName();
                }).collect(Collectors.toList());
    }
    
    private List<String> generateQuestionMarks(List<String> list) {
        return list.stream().map(item -> "?").collect(Collectors.toList());
    }
    
}
